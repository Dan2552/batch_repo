#!/usr/bin/env ruby

require "batch_repo"

ENV["BATCH_REPO_ROOT"] ||= Dir.pwd
ENV["DRY_RUN"] ||= "true" if ARGV.include?("--dry-run")
ENV["DRY_RUN"] = "true" if ENV["DRY_RUN"] == "1"
ENV["VERBOSE"] ||= "true" if ARGV.include?("--verbose")
ENV["VERBOSE"] = "true" if ENV["VERBOSE"] == "1"

puts "DRY RUN MODE" if ENV["DRY_RUN"] == "true"
puts "VERBOSE MODE" if ENV["VERBOSE"] == "true"

def summary
  output = <<~OUTPUT
    Usage:
      #{BatchRepo::DecoratedString.new("batch_repo clone [organisation]").bold}

        Where [organisation] is the org in which to clone all repositories from

      #{BatchRepo::DecoratedString.new("batch_repo update [script]").bold}

        Where [script] will be run agaisnt many repositories. It's recommended
        to run this in a separate directory to where you'd normally work on
        repositories. By default it'll clone a new copy to `./repos/*`.

        Note: This is a destructive action. It will force push to the target
        branch.

        The script file needs the following methods defined in a class called
        `Update`:
        * `run_on_each_repo` - the operation you want to perform on each repo
        * `branch` - the branch name (`String`)
        * `commit_message` - the commit message (`String`)
        * `repos` - the list of repositories (`Array` of `String` elements) that
          the script will actually be run agaisnt

        Optional arguments:
        * --verbose
        * --dry-run
  OUTPUT
  puts output
  exit 1
end

begin
  case ARGV[0]
  when "clone"
    puts "TODO"
  when "update"
    update = BatchRepo::Update.new(ARGV[1])
    summary unless update.valid?
    update.run
  else
    summary
  end
rescue Interrupt
  STDERR.puts "Cancelled"
  exit 1
end
